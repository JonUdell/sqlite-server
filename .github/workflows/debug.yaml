name: Debug SQLite Extension Loading

on:
  workflow_dispatch:
    inputs:
      debug_level:
        description: "Debug detail level (1-3)"
        required: true
        default: "2"
        type: choice
        options:
          - "1"
          - "2"
          - "3"

jobs:
  debug-extensions:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.21'

    - name: Install build dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y gcc make wget libsqlite3-dev sqlite3

    - name: Check system SQLite
      run: |
        echo "ðŸ” Checking system SQLite version and compile options:"
        sqlite3 --version
        echo "PRAGMA compile_options;" | sqlite3 :memory:
        
        # Check if extension loading is enabled
        echo "SELECT 1 FROM pragma_compile_options WHERE compile_options LIKE '%ENABLE_LOAD_EXTENSION%';" | sqlite3 :memory:
        echo "SELECT 1 FROM pragma_compile_options WHERE compile_options LIKE '%ALLOW_LOAD_EXTENSION%';" | sqlite3 :memory:

    - name: Build custom SQLite
      run: |
        wget https://www.sqlite.org/2023/sqlite-autoconf-3420000.tar.gz
        tar xzf sqlite-autoconf-3420000.tar.gz
        cd sqlite-autoconf-3420000
        
        export CFLAGS="-DSQLITE_ENABLE_LOAD_EXTENSION=1 -DSQLITE_ALLOW_LOAD_EXTENSION=1"
        ./configure --prefix=$HOME/sqlite
        
        # Force patch Makefile
        sed -i 's|^CFLAGS = |CFLAGS = -DSQLITE_ENABLE_LOAD_EXTENSION=1 -DSQLITE_ALLOW_LOAD_EXTENSION=1 |' Makefile
        
        echo "ðŸ” Checking Makefile for compile flags:"
        grep -i allow_load_extension Makefile || true
        grep -i enable_load_extension Makefile || true
        
        make CFLAGS="$CFLAGS" -j4
        make install
        
        echo "ðŸ” Checking custom SQLite compile options:"
        echo "PRAGMA compile_options;" | $HOME/sqlite/bin/sqlite3 :memory:

    - name: Create test extension
      if: ${{ github.event.inputs.debug_level >= '2' }}
      run: |
        echo "Creating a simple test extension..."
        cat > test_extension.c << 'EOF'
        #include <sqlite3ext.h>
        #include <stddef.h>  /* For NULL */
        SQLITE_EXTENSION_INIT1

        /* Function needs to be 'void' not 'int' to match expected callback type */
        static void hello_world(sqlite3_context *context, int argc, sqlite3_value **argv) {
          sqlite3_result_text(context, "Hello from extension!", -1, SQLITE_TRANSIENT);
        }

        int sqlite3_testextension_init(sqlite3 *db, char **pzErrMsg, const sqlite3_api_routines *pApi) {
          SQLITE_EXTENSION_INIT2(pApi);
          sqlite3_create_function(db, "hello_ext", 0, SQLITE_UTF8, NULL, hello_world, NULL, NULL);
          return SQLITE_OK;
        }
        EOF
        
        gcc -fPIC -shared -o test_extension.so test_extension.c -I$HOME/sqlite/include

    - name: Native C test
      if: ${{ github.event.inputs.debug_level >= '2' }}
      run: |
        echo "Testing extension loading with native C code..."
        cat > test_load.c << 'EOF'
        #include <stdio.h>
        #include <sqlite3.h>

        int main() {
            sqlite3 *db;
            char *err_msg = NULL;
            
            printf("Opening database...\n");
            if (sqlite3_open(":memory:", &db) != SQLITE_OK) {
                printf("Failed to open database\n");
                return 1;
            }
            
            printf("Enabling extension loading...\n");
            int enable_result = sqlite3_enable_load_extension(db, 1);
            printf("Enable result: %d\n", enable_result);
            
            printf("Loading extension...\n");
            int load_result = sqlite3_load_extension(db, "./test_extension.so", "sqlite3_testextension_init", &err_msg);
            printf("Load result: %d\n", load_result);
            if (err_msg != NULL) {
                printf("Error message: %s\n", err_msg);
                sqlite3_free(err_msg);
            }
            
            if (load_result == SQLITE_OK) {
                printf("Testing extension function...\n");
                sqlite3_stmt *stmt;
                sqlite3_prepare_v2(db, "SELECT hello_ext();", -1, &stmt, NULL);
                if (sqlite3_step(stmt) == SQLITE_ROW) {
                    printf("Function result: %s\n", sqlite3_column_text(stmt, 0));
                }
                sqlite3_finalize(stmt);
            }
            
            sqlite3_close(db);
            return 0;
        }
        EOF
        
        gcc -o test_load test_load.c -lsqlite3
        ./test_load
        
        # Try with custom SQLite
        gcc -o test_load_custom test_load.c -I$HOME/sqlite/include -L$HOME/sqlite/lib -lsqlite3
        LD_LIBRARY_PATH=$HOME/sqlite/lib ./test_load_custom

    - name: Patch go-sqlite3
      run: |
        echo "Patching go-sqlite3 driver..."
        go mod edit -replace github.com/mattn/go-sqlite3=./go-sqlite3
        git clone https://github.com/mattn/go-sqlite3.git
        cd go-sqlite3
        
        # Apply extension loading patches
        sed -i 's|#cgo CFLAGS:|#cgo CFLAGS: -DSQLITE_ENABLE_LOAD_EXTENSION=1 -DSQLITE_ALLOW_LOAD_EXTENSION=1|' sqlite3.go
        sed -i '/return nil, errors.New("sqlite succeeded without returning a database")/a \\n\tC.sqlite3_enable_load_extension(db, 1)' sqlite3.go
        
        # Add debug info
        if [ "${{ github.event.inputs.debug_level }}" -ge "3" ]; then
          sed -i '/func (c \*SQLiteConn) LoadExtension(path string, entryPoint string) error {/a \\tfmt.Printf("DEBUG: Loading extension %s with entry point %s\\n", path, entryPoint)' conn.go
        fi

    - name: Create Go test app
      run: |
        echo "Creating Go test application..."
        cat > extension_test.go << 'EOF'
        package main

        import (
          "database/sql"
          "fmt"
          "log"
          "os"
          "path/filepath"

          _ "github.com/mattn/go-sqlite3"
        )

        func main() {
          log.SetFlags(log.LstdFlags | log.Lshortfile)
          
          // Print current working directory and files
          pwd, _ := os.Getwd()
          fmt.Printf("Working directory: %s\n", pwd)
          
          files, _ := filepath.Glob("*.so")
          fmt.Printf("SO files in directory: %v\n", files)
          
          // Open database with extension loading enabled
          db, err := sql.Open("sqlite3", "test.db?_allow_load_extension=1")
          if err != nil {
            log.Fatalf("Failed to open database: %v", err)
          }
          defer db.Close()
          
          // Check SQLite version
          var version string
          if err := db.QueryRow("SELECT sqlite_version()").Scan(&version); err != nil {
            fmt.Printf("Failed to get SQLite version: %v\n", err)
          } else {
            fmt.Printf("SQLite version: %s\n", version)
          }
          
          // Print compile options
          rows, err := db.Query("PRAGMA compile_options;")
          if err != nil {
            fmt.Printf("Failed to query compile options: %v\n", err)
          } else {
            fmt.Println("SQLite compile options:")
            for rows.Next() {
              var option string
              rows.Scan(&option)
              fmt.Printf("  - %s\n", option)
            }
            rows.Close()
          }
          
          // Try to enable extension loading with PRAGMA
          if _, err := db.Exec("PRAGMA enable_load_extension = ON;"); err != nil {
            fmt.Printf("Failed to enable extensions via PRAGMA: %v\n", err)
          } else {
            fmt.Println("Successfully enabled extensions via PRAGMA")
          }
          
          // Try loading the extension
          extensionPath := "./test_extension.so"
          absPath, _ := filepath.Abs(extensionPath)
          fmt.Printf("Loading extension from: %s\n", absPath)
          
          _, err = db.Exec("SELECT load_extension(?)", absPath)
          if err != nil {
            fmt.Printf("FAILED to load extension: %v\n", err)
            
            // Additional debug info
            if len(os.Args) > 1 && os.Args[1] == "debug" {
              for i, method := range []string{
                fmt.Sprintf("SELECT load_extension('%s')", absPath),
                fmt.Sprintf("SELECT load_extension('%s', NULL)", absPath),
                "SELECT load_extension('./test_extension')",
              } {
                fmt.Printf("Trying method %d: %s\n", i+1, method)
                _, err := db.Exec(method)
                fmt.Printf("  Result: %v\n", err)
              }
            }
          } else {
            fmt.Println("Extension loaded successfully!")
            
            // Test the extension function
            var result string
            err := db.QueryRow("SELECT hello_ext()").Scan(&result)
            if err != nil {
              fmt.Printf("Failed to call extension function: %v\n", err)
            } else {
              fmt.Printf("Extension function result: %s\n", result)
            }
          }
        }
        EOF

    - name: Build and test with system SQLite
      run: |
        echo "Testing with system SQLite..."
        export CGO_ENABLED=1
        go build -tags "sqlite3_load_extension" -v extension_test.go
        ./extension_test debug

    - name: Build and test with custom SQLite
      run: |
        echo "Testing with custom-built SQLite..."
        export CGO_ENABLED=1
        export CGO_CFLAGS="-I$HOME/sqlite/include"
        export CGO_LDFLAGS="-L$HOME/sqlite/lib -lsqlite3"
        go build -tags "sqlite3_load_extension" -v -o extension_test_custom extension_test.go
        LD_LIBRARY_PATH=$HOME/sqlite/lib ./extension_test_custom debug

    - name: Advanced debugging
      if: ${{ github.event.inputs.debug_level == '3' }}
      run: |
        echo "Running advanced debugging tests..."
        
        # Check extension file details
        file test_extension.so
        ldd test_extension.so
        
        # Check permissions
        ls -la test_extension.so
        chmod 755 test_extension.so
        
        # Try with SELinux/AppArmor checks
        if command -v sestatus &> /dev/null; then
            sestatus
        fi
        
        if command -v apparmor_status &> /dev/null; then
            sudo apparmor_status
        fi
        
        # Try with sudo
        if [ "${{ github.event.inputs.debug_level }}" == "3" ]; then
            sudo LD_LIBRARY_PATH=$HOME/sqlite/lib ./extension_test_custom debug
        fi