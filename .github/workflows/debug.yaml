name: Debug SQLite Extension Loading

on:
  workflow_dispatch:
    inputs:
      debug_level:
        description: "Debug detail level (1-3)"
        required: true
        default: "2"
        type: choice
        options:
          - "1"
          - "2"
          - "3"

jobs:
  debug-extensions:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.21'

    - name: Install build dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y gcc make wget libsqlite3-dev sqlite3

    - name: Check system SQLite
      run: |
        echo "ðŸ” Checking system SQLite version and compile options:"
        sqlite3 --version
        echo "PRAGMA compile_options;" | sqlite3 :memory:
        
        # Check if extension loading is enabled
        echo "SELECT 1 FROM pragma_compile_options WHERE compile_options LIKE '%ENABLE_LOAD_EXTENSION%';" | sqlite3 :memory:
        echo "SELECT 1 FROM pragma_compile_options WHERE compile_options LIKE '%ALLOW_LOAD_EXTENSION%';" | sqlite3 :memory:

    - name: Build custom SQLite
      run: |
        wget https://www.sqlite.org/2023/sqlite-autoconf-3420000.tar.gz
        tar xzf sqlite-autoconf-3420000.tar.gz
        cd sqlite-autoconf-3420000
        
        export CFLAGS="-DSQLITE_ENABLE_LOAD_EXTENSION=1 -DSQLITE_ALLOW_LOAD_EXTENSION=1"
        ./configure --prefix=$HOME/sqlite
        
        # Force patch Makefile
        sed -i 's|^CFLAGS = |CFLAGS = -DSQLITE_ENABLE_LOAD_EXTENSION=1 -DSQLITE_ALLOW_LOAD_EXTENSION=1 |' Makefile
        
        echo "ðŸ” Checking Makefile for compile flags:"
        grep -i allow_load_extension Makefile || true
        grep -i enable_load_extension Makefile || true
        
        make CFLAGS="$CFLAGS" -j4
        make install
        
        echo "ðŸ” Checking custom SQLite compile options:"
        echo "PRAGMA compile_options;" | $HOME/sqlite/bin/sqlite3 :memory:

    - name: Create test extension
      if: ${{ github.event.inputs.debug_level >= '2' }}
      run: |
        echo "Creating a simple test extension..."
        cat > test_extension.c << 'EOF'
        #include <sqlite3ext.h>
        #include <stddef.h>  /* For NULL */
        SQLITE_EXTENSION_INIT1

        /* Function needs to be 'void' not 'int' to match expected callback type */
        static void hello_world(sqlite3_context *context, int argc, sqlite3_value **argv) {
          sqlite3_result_text(context, "Hello from extension!", -1, SQLITE_TRANSIENT);
        }

        int sqlite3_testextension_init(sqlite3 *db, char **pzErrMsg, const sqlite3_api_routines *pApi) {
          SQLITE_EXTENSION_INIT2(pApi);
          sqlite3_create_function(db, "hello_ext", 0, SQLITE_UTF8, NULL, hello_world, NULL, NULL);
          return SQLITE_OK;
        }
        EOF
        
        gcc -fPIC -shared -o test_extension.so test_extension.c -I$HOME/sqlite/include

    - name: Native C test
      if: ${{ github.event.inputs.debug_level >= '2' }}
      run: |
        echo "Testing extension loading with native C code..."
        cat > test_load.c << 'EOF'
        #include <stdio.h>
        #include <sqlite3.h>

        int main() {
            sqlite3 *db;
            char *err_msg = NULL;
            
            printf("Opening database...\n");
            if (sqlite3_open(":memory:", &db) != SQLITE_OK) {
                printf("Failed to open database\n");
                return 1;
            }
            
            printf("Enabling extension loading...\n");
            int enable_result = sqlite3_enable_load_extension(db, 1);
            printf("Enable result: %d\n", enable_result);
            
            printf("Loading extension...\n");
            int load_result = sqlite3_load_extension(db, "./test_extension.so", "sqlite3_testextension_init", &err_msg);
            printf("Load result: %d\n", load_result);
            if (err_msg != NULL) {
                printf("Error message: %s\n", err_msg);
                sqlite3_free(err_msg);
            }
            
            if (load_result == SQLITE_OK) {
                printf("Testing extension function...\n");
                sqlite3_stmt *stmt;
                sqlite3_prepare_v2(db, "SELECT hello_ext();", -1, &stmt, NULL);
                if (sqlite3_step(stmt) == SQLITE_ROW) {
                    printf("Function result: %s\n", sqlite3_column_text(stmt, 0));
                }
                sqlite3_finalize(stmt);
            }
            
            sqlite3_close(db);
            return 0;
        }
        EOF
        
        gcc -o test_load test_load.c -lsqlite3
        ./test_load
        
        # Try with custom SQLite
        gcc -o test_load_custom test_load.c -I$HOME/sqlite/include -L$HOME/sqlite/lib -lsqlite3
        LD_LIBRARY_PATH=$HOME/sqlite/lib ./test_load_custom

    - name: Patch go-sqlite3
      run: |
        echo "Patching go-sqlite3 driver..."
        go mod edit -replace github.com/mattn/go-sqlite3=./go-sqlite3
        git clone https://github.com/mattn/go-sqlite3.git
        cd go-sqlite3
        
        # Apply extension loading patches
        sed -i 's|#cgo CFLAGS:|#cgo CFLAGS: -DSQLITE_ENABLE_LOAD_EXTENSION=1 -DSQLITE_ALLOW_LOAD_EXTENSION=1|' sqlite3.go
        sed -i '/return nil, errors.New("sqlite succeeded without returning a database")/a \\n\tC.sqlite3_enable_load_extension(db, 1)' sqlite3.go
        
        # Add debug info
        if [ "${{ github.event.inputs.debug_level }}" -ge "3" ]; then
          sed -i '/func (c \*SQLiteConn) LoadExtension(path string, entryPoint string) error {/a \\tfmt.Printf("DEBUG: Loading extension %s with entry point %s\\n", path, entryPoint)' conn.go
        fi

    - name: Create Go test app
      run: |
        echo "Creating Go test application..."
        cat > extension_test.go << 'EOF'
        package main

        import (
          "database/sql"
          "fmt"
          "log"
          "os"
          "path/filepath"

          _ "github.com/mattn/go-sqlite3"
        )

        func main() {
          log.SetFlags(log.LstdFlags | log.Lshortfile)
          
          // Print current working directory and files
          pwd, _ := os.Getwd()
          fmt.Printf("Working directory: %s\n", pwd)
          
          files, _ := filepath.Glob("*.so")
          fmt.Printf("SO files in directory: %v\n", files)
          
          // Open database with extension loading enabled
          db, err := sql.Open("sqlite3", "test.db?_allow_load_extension=1")
          if err != nil {
            log.Fatalf("Failed to open database: %v", err)
          }
          defer db.Close()
          
          // Check SQLite version
          var version string
          if err := db.QueryRow("SELECT sqlite_version()").Scan(&version); err != nil {
            fmt.Printf("Failed to get SQLite version: %v\n", err)
          } else {
            fmt.Printf("SQLite version: %s\n", version)
          }
          
          // Print compile options
          rows, err := db.Query("PRAGMA compile_options;")
          if err != nil {
            fmt.Printf("Failed to query compile options: %v\n", err)
          } else {
            fmt.Println("SQLite compile options:")
            for rows.Next() {
              var option string
              rows.Scan(&option)
              fmt.Printf("  - %s\n", option)
            }
            rows.Close()
          }
          
          // Try to enable extension loading with PRAGMA
          if _, err := db.Exec("PRAGMA enable_load_extension = ON;"); err != nil {
            fmt.Printf("Failed to enable extensions via PRAGMA: %v\n", err)
          } else {
            fmt.Println("Successfully enabled extensions via PRAGMA")
          }
          
          // Try loading the extension
          extensionPath := "./test_extension.so"
          absPath, _ := filepath.Abs(extensionPath)
          fmt.Printf("Loading extension from: %s\n", absPath)
          
          _, err = db.Exec("SELECT load_extension(?)", absPath)
          if err != nil {
            fmt.Printf("FAILED to load extension: %v\n", err)
            
            // Additional debug info
            if len(os.Args) > 1 && os.Args[1] == "debug" {
              for i, method := range []string{
                fmt.Sprintf("SELECT load_extension('%s')", absPath),
                fmt.Sprintf("SELECT load_extension('%s', NULL)", absPath),
                "SELECT load_extension('./test_extension')",
              } {
                fmt.Printf("Trying method %d: %s\n", i+1, method)
                _, err := db.Exec(method)
                fmt.Printf("  Result: %v\n", err)
              }
            }
          } else {
            fmt.Println("Extension loaded successfully!")
            
            // Test the extension function
            var result string
            err := db.QueryRow("SELECT hello_ext()").Scan(&result)
            if err != nil {
              fmt.Printf("Failed to call extension function: %v\n", err)
            } else {
              fmt.Printf("Extension function result: %s\n", result)
            }
          }
        }
        EOF

    - name: Build and test with system SQLite
      run: |
        echo "Testing with system SQLite..."
        export CGO_ENABLED=1
        
        # Show current directory and files
        echo "Current directory: $(pwd)"
        echo "Files in directory:"
        ls -la
        
        # Make sure the extension_test.go file exists and has content
        echo "Content of extension_test.go:"
        cat extension_test.go
        
        # Ensure we build with correct output name
        echo "Building extension_test..."
        go build -tags "sqlite3_load_extension" -v -o extension_test ./extension_test.go
        
        # Make sure file exists before running
        if [ -f "./extension_test" ]; then
          echo "Running extension_test..."
          ./extension_test debug
        else
          echo "ERROR: extension_test binary not found after build!"
          ls -la
        fi

    - name: Build and test with custom SQLite
      run: |
        echo "Testing with custom-built SQLite..."
        export CGO_ENABLED=1
        export CGO_CFLAGS="-I$HOME/sqlite/include"
        export CGO_LDFLAGS="-L$HOME/sqlite/lib -lsqlite3"
        
        echo "Building custom extension test..."
        go build -tags "sqlite3_load_extension" -v -o extension_test_custom ./extension_test.go
        
        if [ -f "./extension_test_custom" ]; then
          echo "Running custom extension test..."
          LD_LIBRARY_PATH=$HOME/sqlite/lib ./extension_test_custom debug
        else
          echo "ERROR: extension_test_custom binary not found after build!"
          ls -la
        fi

    - name: Advanced debugging
      if: ${{ github.event.inputs.debug_level == '3' }}
      run: |
        echo "Running advanced debugging tests..."
        
        # Check extension file details
        file test_extension.so
        ldd test_extension.so
        
        # Check permissions
        ls -la test_extension.so
        chmod 755 test_extension.so
        
        # Try with SELinux/AppArmor checks
        if command -v sestatus &> /dev/null; then
            sestatus
        fi
        
        if command -v apparmor_status &> /dev/null; then
            sudo apparmor_status
        fi
        
        # Try with sudo
        if [ "${{ github.event.inputs.debug_level }}" == "3" ]; then
            sudo LD_LIBRARY_PATH=$HOME/sqlite/lib ./extension_test_custom debug
        fi
        
    - name: Run specific sqlite-server diagnostic test
      run: |
        # Create a specialized test program to verify SQLite extension loading works with proper static linking
        cat > sqlite_server_diagnostic.go <<'EOF'
        package main

        import (
          "database/sql"
          "fmt"
          "log"
          "os"
          _ "github.com/mattn/go-sqlite3"
        )

        func main() {
          log.SetFlags(log.LstdFlags | log.Lshortfile)
          
          log.Println("ðŸ” SQLite Server Extension Loading Diagnostic")
          log.Println("============================================")
          
          // Try to open the database with extension loading enabled
          log.Println("ðŸ” Opening database with _allow_load_extension=1...")
          db, err := sql.Open("sqlite3", ":memory:?_allow_load_extension=1")
          if err != nil {
            log.Fatalf("Failed to open database: %v", err)
          }
          defer db.Close()
          
          // Check SQLite version first
          var version string
          err = db.QueryRow("SELECT sqlite_version()").Scan(&version)
          if err != nil {
            log.Printf("âŒ Failed to get SQLite version: %v", err)
          } else {
            log.Printf("âœ… SQLite version: %s", version)
          }
          
          // Print all compile options to see what's available
          log.Println("ðŸ” Checking all SQLite compile options:")
          rows, err := db.Query("PRAGMA compile_options;")
          if err != nil {
            log.Printf("âŒ Failed to query compile options: %v", err)
          } else {
            defer rows.Close()
            for rows.Next() {
              var option string
              rows.Scan(&option)
              log.Printf("  - %s", option)
            }
          }
          
          // Try BOTH ways of enabling extension loading
          
          // Method 1: via connection string parameter
          log.Println("ðŸ” Method 1: Checking if extension loading is enabled via connection string...")
          var allowExt int
          err = db.QueryRow("PRAGMA allow_load_extension;").Scan(&allowExt)
          if err != nil {
            log.Printf("âŒ Could not query allow_load_extension setting: %v", err)
          } else {
            log.Printf("ðŸ” allow_load_extension PRAGMA value: %d", allowExt)
          }
          
          // Method 2: via SQL
          log.Println("ðŸ” Method 2: Trying to enable extension loading via SQL...")
          _, err = db.Exec("SELECT sqlite3_enable_load_extension(1)")
          if err != nil {
            log.Printf("âŒ Failed to enable load_extension via SQL: %v", err)
          } else {
            log.Println("âœ… Successfully enabled load_extension via SQL")
            
            // Verify setting after SQL enable
            db.QueryRow("PRAGMA allow_load_extension;").Scan(&allowExt)
            log.Printf("ðŸ” allow_load_extension PRAGMA value after SQL enable: %d", allowExt)
          }
          
          // Check if SQLITE_ENABLE_LOAD_EXTENSION was compiled in
          log.Println("ðŸ” Checking compile options for extension loading...")
          var enableLoadExt, allowLoadExt int
          db.QueryRow("SELECT sqlite_compileoption_used('SQLITE_ENABLE_LOAD_EXTENSION')").Scan(&enableLoadExt)
          db.QueryRow("SELECT sqlite_compileoption_used('SQLITE_ALLOW_LOAD_EXTENSION')").Scan(&allowLoadExt)
          log.Printf("âœ… SQLITE_ENABLE_LOAD_EXTENSION compile option: %d", enableLoadExt)
          log.Printf("âœ… SQLITE_ALLOW_LOAD_EXTENSION compile option: %d", allowLoadExt)
          
          // Get sqlite3_load_extension symbol status
          log.Println("ðŸ” Checking load_extension function availability...")
          var result string
          err = db.QueryRow("SELECT CASE WHEN (SELECT COUNT(*) FROM pragma_function_list WHERE name='load_extension')>0 THEN 'Available' ELSE 'Not Available' END").Scan(&result)
          if err != nil {
            log.Printf("âŒ Error checking load_extension function: %v", err)
          } else {
            log.Printf("ðŸ” load_extension function is: %s", result)
          }
          
          // Try loading our test extension
          if len(os.Args) > 1 && os.Args[1] == "tryload" {
            extensionPath := "./test_extension.so"
            log.Printf("ðŸ” Attempting to load extension from %s...", extensionPath)
            _, err = db.Exec("SELECT load_extension(?)", extensionPath)
            if err != nil {
              log.Printf("âŒ Failed to load extension: %v", err)
            } else {
              log.Println("âœ… Successfully loaded extension!")
              
              // Test extension function
              var hello string
              err = db.QueryRow("SELECT hello_ext()").Scan(&hello)
              if err != nil {
                log.Printf("âŒ Failed to call extension function: %v", err)
              } else {
                log.Printf("âœ… Extension function result: %s", hello)
              }
            }
          }
        }
        EOF
        
        # Show current directory and files before building
        echo "Current directory: $(pwd)"
        echo "Files in directory:"
        ls -la
        
        # Build and run both non-static and static versions
        echo "ðŸ”§ Building and testing with system SQLite..."
        export CGO_ENABLED=1
        
        # Make sure the sqlite_server_diagnostic.go file exists and has content
        echo "Content of sqlite_server_diagnostic.go:"
        cat sqlite_server_diagnostic.go
        
        echo "Building system SQLite diagnostic binary..."
        go build -tags "sqlite3_load_extension" -v -o sqlite_server_diagnostic_system ./sqlite_server_diagnostic.go
        
        if [ -f "./sqlite_server_diagnostic_system" ]; then
          echo "Running system SQLite diagnostic..."
          ./sqlite_server_diagnostic_system tryload
        else
          echo "ERROR: sqlite_server_diagnostic_system binary not found after build!"
          ls -la
        fi
        
        echo "ðŸ”§ Building and testing with static custom SQLite..."
        export CGO_ENABLED=1
        export CGO_CFLAGS="-I$HOME/sqlite/include -DSQLITE_ENABLE_LOAD_EXTENSION=1 -DSQLITE_ALLOW_LOAD_EXTENSION=1"
        export CGO_LDFLAGS="-static $HOME/sqlite/lib/libsqlite3.a -ldl -lm"
        
        echo "Building static SQLite diagnostic binary..."
        go build -tags "sqlite3_load_extension" -ldflags="-linkmode external" -v -o sqlite_server_diagnostic_static ./sqlite_server_diagnostic.go
        
        if [ -f "./sqlite_server_diagnostic_static" ]; then
          echo "Running static SQLite diagnostic..."
          ./sqlite_server_diagnostic_static tryload
        else
          echo "ERROR: sqlite_server_diagnostic_static binary not found after build!"
          ls -la
        fi
        
    - name: Test build-local script simulation
      run: |
        echo "ðŸ§ª Testing build script similar to local Mac build..."
        
        # Get current directory
        pwd=$(pwd)
        echo "Current directory: $(pwd)"
        echo "Files in directory:"
        ls -la
        
        # Create simulation of build-local.sh for Linux
        cat > build-linux-test.sh << EOF
        #!/bin/bash
        set -ex
        
        echo "Building with approach similar to local Mac build..."
        export CGO_ENABLED=1
        export CGO_CFLAGS="-I\$HOME/sqlite/include"
        export CGO_LDFLAGS="\$HOME/sqlite/lib/libsqlite3.a -lm -ldl"
        
        go build -tags "sqlite3_load_extension" -v -o sqlite-server-build-local ./sqlite-server.go
        EOF
        
        chmod +x build-linux-test.sh
        ./build-linux-test.sh
        
        # Verify the file exists
        if [ -f "./sqlite-server-build-local" ]; then
          echo "ðŸ§ª Testing extension loading with build-local approach binary..."
          ./sqlite-server-build-local
        else
          echo "ERROR: sqlite-server-build-local binary not found after build!"
          ls -la
        fi