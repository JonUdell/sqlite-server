name: Debug SQLite Extension Loading

on:
  workflow_dispatch:
    inputs:
      debug_level:
        description: "Debug detail level (1-3)"
        required: true
        default: "2"
        type: choice
        options:
          - "1"
          - "2"
          - "3"

jobs:
  debug-extensions:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.21'

    - name: Install build dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y gcc make wget libsqlite3-dev sqlite3

    - name: Check system SQLite
      run: |
        echo "ðŸ” Checking system SQLite version and compile options:"
        sqlite3 --version
        echo "PRAGMA compile_options;" | sqlite3 :memory:
        
        # Check if extension loading is enabled
        echo "SELECT 1 FROM pragma_compile_options WHERE compile_options LIKE '%ENABLE_LOAD_EXTENSION%';" | sqlite3 :memory:
        echo "SELECT 1 FROM pragma_compile_options WHERE compile_options LIKE '%ALLOW_LOAD_EXTENSION%';" | sqlite3 :memory:

    - name: Build custom SQLite
      run: |
        wget https://www.sqlite.org/2023/sqlite-autoconf-3420000.tar.gz
        tar xzf sqlite-autoconf-3420000.tar.gz
        cd sqlite-autoconf-3420000
        
        export CFLAGS="-DSQLITE_ENABLE_LOAD_EXTENSION=1 -DSQLITE_ALLOW_LOAD_EXTENSION=1"
        ./configure --prefix=$HOME/sqlite
        
        # Force patch Makefile
        sed -i 's|^CFLAGS = |CFLAGS = -DSQLITE_ENABLE_LOAD_EXTENSION=1 -DSQLITE_ALLOW_LOAD_EXTENSION=1 |' Makefile
        
        echo "ðŸ” Checking Makefile for compile flags:"
        grep -i allow_load_extension Makefile || true
        grep -i enable_load_extension Makefile || true
        
        make CFLAGS="$CFLAGS" -j4
        make install
        
        echo "ðŸ” Checking custom SQLite compile options:"
        echo "PRAGMA compile_options;" | $HOME/sqlite/bin/sqlite3 :memory:

    - name: Create test extension
      if: ${{ github.event.inputs.debug_level >= '2' }}
      run: |
        echo "Creating a simple test extension..."
        cat > test_extension.c << 'EOF'
        #include <sqlite3ext.h>
        #include <stddef.h>  /* For NULL */
        SQLITE_EXTENSION_INIT1

        /* Function needs to be 'void' not 'int' to match expected callback type */
        static void hello_world(sqlite3_context *context, int argc, sqlite3_value **argv) {
          sqlite3_result_text(context, "Hello from extension\!", -1, SQLITE_TRANSIENT);
        }

        int sqlite3_testextension_init(sqlite3 *db, char **pzErrMsg, const sqlite3_api_routines *pApi) {
          SQLITE_EXTENSION_INIT2(pApi);
          sqlite3_create_function(db, "hello_ext", 0, SQLITE_UTF8, NULL, hello_world, NULL, NULL);
          return SQLITE_OK;
        }
        EOF
        
        gcc -fPIC -shared -o test_extension.so test_extension.c -I$HOME/sqlite/include

    - name: Native C test
      if: ${{ github.event.inputs.debug_level >= '2' }}
      run: |
        echo "Testing extension loading with native C code..."
        cat > test_load.c << 'EOF'
        #include <stdio.h>
        #include <sqlite3.h>

        int main() {
            sqlite3 *db;
            char *err_msg = NULL;
            
            printf("Opening database...\n");
            if (sqlite3_open(":memory:", &db) \!= SQLITE_OK) {
                printf("Failed to open database\n");
                return 1;
            }
            
            printf("Enabling extension loading...\n");
            int enable_result = sqlite3_enable_load_extension(db, 1);
            printf("Enable result: %d\n", enable_result);
            
            printf("Loading extension...\n");
            int load_result = sqlite3_load_extension(db, "./test_extension.so", "sqlite3_testextension_init", &err_msg);
            printf("Load result: %d\n", load_result);
            if (err_msg \!= NULL) {
                printf("Error message: %s\n", err_msg);
                sqlite3_free(err_msg);
            }
            
            if (load_result == SQLITE_OK) {
                printf("Testing extension function...\n");
                sqlite3_stmt *stmt;
                sqlite3_prepare_v2(db, "SELECT hello_ext();", -1, &stmt, NULL);
                if (sqlite3_step(stmt) == SQLITE_ROW) {
                    printf("Function result: %s\n", sqlite3_column_text(stmt, 0));
                }
                sqlite3_finalize(stmt);
            }
            
            sqlite3_close(db);
            return 0;
        }
        EOF
        
        gcc -o test_load test_load.c -lsqlite3
        ./test_load
        
        # Try with custom SQLite
        gcc -o test_load_custom test_load.c -I$HOME/sqlite/include -L$HOME/sqlite/lib -lsqlite3
        LD_LIBRARY_PATH=$HOME/sqlite/lib ./test_load_custom

    - name: Patch go-sqlite3
      run: |
        echo "Patching go-sqlite3 driver..."
        go mod edit -replace github.com/mattn/go-sqlite3=./go-sqlite3
        git clone https://github.com/mattn/go-sqlite3.git
        cd go-sqlite3
        
        # Apply extension loading patches
        sed -i 's|#cgo CFLAGS:|#cgo CFLAGS: -DSQLITE_ENABLE_LOAD_EXTENSION=1 -DSQLITE_ALLOW_LOAD_EXTENSION=1|' sqlite3.go
        sed -i '/return nil, errors.New("sqlite succeeded without returning a database")/a \\n\tC.sqlite3_enable_load_extension(db, 1)' sqlite3.go
        
        # Add debug info
        if [ "${{ github.event.inputs.debug_level }}" -ge "3" ]; then
          sed -i '/func (c \*SQLiteConn) LoadExtension(path string, entryPoint string) error {/a \\tfmt.Printf("DEBUG: Loading extension %s with entry point %s\\n", path, entryPoint)' conn.go
        fi

    - name: Create Go test app
      run: |
        echo "Creating Go test application..."
        cat > extension_test.go << 'EOF'
        package main

        import (
          "database/sql"
          "fmt"
          "log"
          "os"
          "path/filepath"

          _ "github.com/mattn/go-sqlite3"
        )

        func main() {
          log.SetFlags(log.LstdFlags | log.Lshortfile)
          
          // Print current working directory and files
          pwd, _ := os.Getwd()
          fmt.Printf("Working directory: %s\n", pwd)
          
          files, _ := filepath.Glob("*.so")
          fmt.Printf("SO files in directory: %v\n", files)
          
          // Open database with extension loading enabled
          fmt.Println("\nðŸ”Ž Opening database with _allow_load_extension=1...")
          db, err := sql.Open("sqlite3", "test.db?_allow_load_extension=1")
          if err \!= nil {
            log.Fatalf("Failed to open database: %v", err)
          }
          defer db.Close()
          
          // Check SQLite version
          var version string
          if err := db.QueryRow("SELECT sqlite_version()").Scan(&version); err \!= nil {
            fmt.Printf("Failed to get SQLite version: %v\n", err)
          } else {
            fmt.Printf("SQLite version: %s\n", version)
          }
          
          // Print compile options
          rows, err := db.Query("PRAGMA compile_options;")
          if err \!= nil {
            fmt.Printf("Failed to query compile options: %v\n", err)
          } else {
            fmt.Println("SQLite compile options:")
            for rows.Next() {
              var option string
              rows.Scan(&option)
              fmt.Printf("  - %s\n", option)
            }
            rows.Close()
          }
          
          // Check if we can see allow_load_extension PRAGMA
          fmt.Println("\nðŸ”Ž Checking allow_load_extension PRAGMA before enabling...")
          var allowExt int
          if err := db.QueryRow("PRAGMA allow_load_extension;").Scan(&allowExt); err \!= nil {
            fmt.Printf("âŒ Cannot query allow_load_extension PRAGMA: %v\n", err)
          } else {
            fmt.Printf("ðŸ”Ž allow_load_extension PRAGMA value: %d\n", allowExt)
          }
          
          // Try BOTH common methods to enable extension loading
          fmt.Println("\nðŸ”Ž Trying to enable extensions using sqlite3_enable_load_extension()...")
          if _, err := db.Exec("SELECT sqlite3_enable_load_extension(1);"); err \!= nil {
            fmt.Printf("âŒ Failed to enable with sqlite3_enable_load_extension(): %v\n", err)
          } else {
            fmt.Println("âœ… Successfully enabled with sqlite3_enable_load_extension()")
          }
          
          fmt.Println("\nðŸ”Ž Trying to enable extensions using PRAGMA...")
          if _, err := db.Exec("PRAGMA enable_load_extension = ON;"); err \!= nil {
            fmt.Printf("âŒ Failed to enable extensions via PRAGMA: %v\n", err)
          } else {
            fmt.Println("âœ… Successfully enabled extensions via PRAGMA")
          }
          
          // Check if extension loading is enabled now
          fmt.Println("\nðŸ”Ž Checking allow_load_extension PRAGMA after enabling...")
          if err := db.QueryRow("PRAGMA allow_load_extension;").Scan(&allowExt); err \!= nil {
            fmt.Printf("âŒ Cannot query allow_load_extension PRAGMA: %v\n", err)
          } else {
            fmt.Printf("ðŸ”Ž allow_load_extension PRAGMA value after enabling: %d\n", allowExt)
          }
          
          // Try loading the extension
          extensionPath := "./test_extension.so"
          absPath, _ := filepath.Abs(extensionPath)
          fmt.Printf("\nLoading extension from: %s\n", absPath)
          
          // Verify extension file permissions and existence
          if fileInfo, err := os.Stat(extensionPath); err \!= nil {
            fmt.Printf("âŒ Extension file error: %v\n", err)
          } else {
            fmt.Printf("ðŸ”Ž Extension file permissions: %v\n", fileInfo.Mode())
            fmt.Printf("ðŸ”Ž Extension file size: %d bytes\n", fileInfo.Size())
          }
          
          // Try different approaches to load the extension
          fmt.Println("\nðŸ”Ž Attempting different methods to load extension...")
          
          // Method 1: Default approach
          fmt.Println("Method 1: Default approach with placeholder")
          _, err = db.Exec("SELECT load_extension(?)", absPath)
          if err \!= nil {
            fmt.Printf("âŒ FAILED: %v\n", err)
            
            // Try with direct string
            fmt.Println("\nMethod 2: Direct command string")
            loadCmd := fmt.Sprintf("SELECT load_extension('%s')", absPath)
            fmt.Printf("Executing: %s\n", loadCmd)
            _, err := db.Exec(loadCmd)
            fmt.Printf("  Result: %v\n", err)
            
            // Try with NULL entry point
            fmt.Println("\nMethod 3: With explicit NULL")
            loadCmd = fmt.Sprintf("SELECT load_extension('%s', NULL)", absPath)
            fmt.Printf("Executing: %s\n", loadCmd)
            _, err = db.Exec(loadCmd)
            fmt.Printf("  Result: %v\n", err)
            
            // Try without extension
            fmt.Println("\nMethod 4: Relative path without extension")
            _, err = db.Exec("SELECT load_extension('./test_extension')")
            fmt.Printf("  Result: %v\n", err)
            
            // Try reopening the database
            fmt.Println("\nMethod 5: Reopening database with fresh connection")
            db.Close()
            db, err = sql.Open("sqlite3", "test.db?_allow_load_extension=1")
            if err \!= nil {
              fmt.Printf("âŒ Failed to reopen database: %v\n", err)
            } else {
              // Enable again
              db.Exec("SELECT sqlite3_enable_load_extension(1)")
              _, err = db.Exec("SELECT load_extension(?)", absPath)
              fmt.Printf("  Result: %v\n", err)
            }
          } else {
            fmt.Println("âœ… Successfully loaded extension\!")
            
            // Test extension function
            var hello string
            err := db.QueryRow("SELECT hello_ext()").Scan(&hello)
            if err \!= nil {
              fmt.Printf("âŒ Failed to call extension function: %v\n", err)
            } else {
              fmt.Printf("âœ… Extension function result: %s\n", hello)
            }
          }
        }
        EOF

    - name: Build and test with system SQLite
      run: |
        echo "Testing with system SQLite..."
        export CGO_ENABLED=1
        
        # Show current directory and files
        echo "Current directory: $(pwd)"
        echo "Files in directory:"
        ls -la
        
        # Create a temporary directory to isolate the build
        mkdir -p test_build
        cp extension_test.go test_build/main.go
        cp test_extension.so test_build/
        cd test_build
        
        # Ensure we build with correct output name
        echo "Building extension_test..."
        go mod init extensiontest
        go mod edit -replace github.com/mattn/go-sqlite3=../go-sqlite3
        go mod tidy
        go build -tags "sqlite3_load_extension" -v -o extension_test
        
        # Make sure file exists before running
        if [ -f "./extension_test" ]; then
          echo "Running extension_test..."
          ./extension_test
        else
          echo "ERROR: extension_test binary not found after build\!"
          ls -la
        fi
        
        # Return to main directory
        cd ..

    - name: Build and test with custom SQLite
      run: |
        echo "Testing with custom-built SQLite..."
        
        # Create a separate directory for this test
        mkdir -p custom_test
        cp extension_test.go custom_test/main.go
        cp test_extension.so custom_test/
        cd custom_test
        
        # Set up a proper Go module
        go mod init customtest
        go mod edit -replace github.com/mattn/go-sqlite3=../go-sqlite3
        go mod tidy
        
        # Configure for custom SQLite
        export CGO_ENABLED=1
        export CGO_CFLAGS="-I$HOME/sqlite/include"
        export CGO_LDFLAGS="-L$HOME/sqlite/lib -lsqlite3"
        
        echo "Building custom extension test..."
        go build -tags "sqlite3_load_extension" -v -o extension_test_custom
        
        if [ -f "./extension_test_custom" ]; then
          echo "Running custom extension test..."
          LD_LIBRARY_PATH=$HOME/sqlite/lib ./extension_test_custom
        else
          echo "ERROR: extension_test_custom binary not found after build\!"
          ls -la
        fi
        
        # Return to main directory
        cd ..

    - name: Advanced debugging
      if: ${{ github.event.inputs.debug_level == '3' }}
      run: |
        echo "Running advanced debugging tests..."
        
        # Check extension file details
        file test_extension.so
        ldd test_extension.so
        
        # Check permissions
        ls -la test_extension.so
        chmod 755 test_extension.so
        
        # Try with SELinux/AppArmor checks
        if command -v sestatus &> /dev/null; then
            sestatus
        fi
        
        if command -v apparmor_status &> /dev/null; then
            sudo apparmor_status
        fi
        
        # Try with sudo
        if [ "${{ github.event.inputs.debug_level }}" == "3" ]; then
            sudo LD_LIBRARY_PATH=$HOME/sqlite/lib ./extension_test_custom debug
        fi
        
    - name: Run specific sqlite-server diagnostic test
      run: |
        # Create a specialized test program to verify SQLite extension loading works with proper static linking
        mkdir -p diagnostic_test
        cat > diagnostic_test/main.go << 'EOF'
        package main

        import (
          "database/sql"
          "fmt"
          "log"
          "os"
          _ "github.com/mattn/go-sqlite3"
        )

        func main() {
          log.SetFlags(log.LstdFlags | log.Lshortfile)
          
          log.Println("ðŸ” SQLite Server Extension Loading Diagnostic")
          log.Println("============================================")
          
          // Try to open the database with extension loading enabled
          log.Println("ðŸ” Opening database with _allow_load_extension=1...")
          db, err := sql.Open("sqlite3", ":memory:?_allow_load_extension=1")
          if err \!= nil {
            log.Fatalf("Failed to open database: %v", err)
          }
          defer db.Close()
          
          // Check SQLite version first
          var version string
          err = db.QueryRow("SELECT sqlite_version()").Scan(&version)
          if err \!= nil {
            log.Printf("âŒ Failed to get SQLite version: %v", err)
          } else {
            log.Printf("âœ… SQLite version: %s", version)
          }
          
          // Print all compile options to see what's available
          log.Println("ðŸ” Checking all SQLite compile options:")
          rows, err := db.Query("PRAGMA compile_options;")
          if err \!= nil {
            log.Printf("âŒ Failed to query compile options: %v", err)
          } else {
            defer rows.Close()
            for rows.Next() {
              var option string
              rows.Scan(&option)
              log.Printf("  - %s", option)
            }
          }
          
          // Try BOTH ways of enabling extension loading
          
          // Method 1: via connection string parameter
          log.Println("ðŸ” Method 1: Checking if extension loading is enabled via connection string...")
          var allowExt int
          err = db.QueryRow("PRAGMA allow_load_extension;").Scan(&allowExt)
          if err \!= nil {
            log.Printf("âŒ Could not query allow_load_extension setting: %v", err)
          } else {
            log.Printf("ðŸ” allow_load_extension PRAGMA value: %d", allowExt)
          }
          
          // Method 2: via SQL
          log.Println("ðŸ” Method 2: Trying to enable extension loading via SQL...")
          _, err = db.Exec("SELECT sqlite3_enable_load_extension(1)")
          if err \!= nil {
            log.Printf("âŒ Failed to enable load_extension via SQL: %v", err)
          } else {
            log.Println("âœ… Successfully enabled load_extension via SQL")
            
            // Verify setting after SQL enable
            db.QueryRow("PRAGMA allow_load_extension;").Scan(&allowExt)
            log.Printf("ðŸ” allow_load_extension PRAGMA value after SQL enable: %d", allowExt)
          }
          
          // Check if SQLITE_ENABLE_LOAD_EXTENSION was compiled in
          log.Println("ðŸ” Checking compile options for extension loading...")
          var enableLoadExt, allowLoadExt int
          db.QueryRow("SELECT sqlite_compileoption_used('SQLITE_ENABLE_LOAD_EXTENSION')").Scan(&enableLoadExt)
          db.QueryRow("SELECT sqlite_compileoption_used('SQLITE_ALLOW_LOAD_EXTENSION')").Scan(&allowLoadExt)
          log.Printf("âœ… SQLITE_ENABLE_LOAD_EXTENSION compile option: %d", enableLoadExt)
          log.Printf("âœ… SQLITE_ALLOW_LOAD_EXTENSION compile option: %d", allowLoadExt)
          
          // Get sqlite3_load_extension symbol status
          log.Println("ðŸ” Checking load_extension function availability...")
          var result string
          err = db.QueryRow("SELECT CASE WHEN (SELECT COUNT(*) FROM pragma_function_list WHERE name='load_extension')>0 THEN 'Available' ELSE 'Not Available' END").Scan(&result)
          if err \!= nil {
            log.Printf("âŒ Error checking load_extension function: %v", err)
          } else {
            log.Printf("ðŸ” load_extension function is: %s", result)
          }
          
          // Try loading our test extension
          if len(os.Args) > 1 && os.Args[1] == "tryload" {
            extensionPath := "./test_extension.so"
            log.Printf("\nðŸ” Attempting to load extension from %s...", extensionPath)
            
            // Verify extension file permissions and existence
            if fileInfo, err := os.Stat(extensionPath); err \!= nil {
              log.Printf("âŒ Extension file error: %v", err)
            } else {
              log.Printf("ðŸ” Extension file permissions: %v", fileInfo.Mode())
              log.Printf("ðŸ” Extension file size: %d bytes", fileInfo.Size())
            }
            
            log.Println("\nðŸ”Ž Trying different extension loading approaches...")
            
            // First try the original approach
            log.Println("Approach 1: Using parameterized query")
            _, err = db.Exec("SELECT load_extension(?)", extensionPath)
            if err \!= nil {
              log.Printf("âŒ FAILED: %v", err)
              
              // Try alternative approaches
              log.Println("\nApproach 2: Using direct SQL")
              loadCmd := fmt.Sprintf("SELECT load_extension('%s')", extensionPath)
              log.Printf("Executing: %s", loadCmd)
              _, err := db.Exec(loadCmd)
              log.Printf("  Result: %v", err)
              
              log.Println("\nApproach 3: Using explicit NULL")
              loadCmd = fmt.Sprintf("SELECT load_extension('%s', NULL)", extensionPath)
              log.Printf("Executing: %s", loadCmd)
              _, err = db.Exec(loadCmd)
              log.Printf("  Result: %v", err)
              
              log.Println("\nApproach 4: Using relative path without extension")
              _, err = db.Exec("SELECT load_extension('./test_extension')")
              log.Printf("  Result: %v", err)
              
              // Try closing and reopening the database
              log.Println("\nApproach 5: Reopening database with fresh connection")
              db.Close()
              db, err = sql.Open("sqlite3", ":memory:?_allow_load_extension=1")
              if err \!= nil {
                log.Printf("âŒ Failed to reopen database: %v", err)
              } else {
                // Enable again
                db.Exec("SELECT sqlite3_enable_load_extension(1)")
                _, err = db.Exec("SELECT load_extension(?)", extensionPath)
                log.Printf("  Result: %v", err)
              }
            } else {
              log.Println("âœ… Successfully loaded extension\!")
              
              // Test extension function
              var hello string
              err = db.QueryRow("SELECT hello_ext()").Scan(&hello)
              if err \!= nil {
                log.Printf("âŒ Failed to call extension function: %v", err)
              } else {
                log.Printf("âœ… Extension function result: %s", hello)
              }
            }
          }
        }
        EOF
        
        # Show current directory and files before building
        echo "Current directory: $(pwd)"
        echo "Files in directory:"
        ls -la
        
        # First, build and test with system SQLite
        echo "ðŸ”§ Building and testing with system SQLite..."
        export CGO_ENABLED=1
        
        # Fix unused import in main.go if needed
        sed -i 's/^import (/import (/; s/"fmt"/"fmt" \/\/ fmt is used/;' diagnostic_test/main.go
        
        # Set up a proper Go module in the diagnostic_test directory
        cd diagnostic_test
        go mod init sqlitediagnostic
        go mod edit -replace github.com/mattn/go-sqlite3=../go-sqlite3
        go mod tidy
        
        # Build with system SQLite
        echo "Building system SQLite diagnostic binary..."
        go build -tags "sqlite3_load_extension" -v -o sqlite_server_diagnostic_system
        
        # Copy the test extension
        cp ../test_extension.so .
        
        if [ -f "./sqlite_server_diagnostic_system" ]; then
          echo "Running system SQLite diagnostic..."
          ./sqlite_server_diagnostic_system tryload
        else
          echo "ERROR: sqlite_server_diagnostic_system binary not found after build\!"
          ls -la
        fi
        
        # Now build with static custom SQLite
        echo "ðŸ”§ Building and testing with static custom SQLite..."
        export CGO_CFLAGS="-I$HOME/sqlite/include -DSQLITE_ENABLE_LOAD_EXTENSION=1 -DSQLITE_ALLOW_LOAD_EXTENSION=1"
        export CGO_LDFLAGS="-static $HOME/sqlite/lib/libsqlite3.a -ldl -lm"
        
        echo "Building static SQLite diagnostic binary..."
        go build -tags "sqlite3_load_extension" -ldflags="-linkmode external" -v -o sqlite_server_diagnostic_static
        
        if [ -f "./sqlite_server_diagnostic_static" ]; then
          echo "Running static SQLite diagnostic..."
          ./sqlite_server_diagnostic_static tryload
        else
          echo "ERROR: sqlite_server_diagnostic_static binary not found after build\!"
          ls -la
        fi
        
        # Return to main directory
        cd ..
        
    - name: Test build-local script simulation
      run: |
        echo "ðŸ§ª Testing build script similar to local Mac build..."
        
        # Create a separate directory for the build-local test
        mkdir -p build_local_test
        cp sqlite-server.go build_local_test/main.go
        cp -r go-sqlite3 build_local_test/
        cd build_local_test
        
        # Set up a proper Go module
        go mod init sqliteserver
        go mod edit -replace github.com/mattn/go-sqlite3=./go-sqlite3
        go mod tidy
        
        # Create a special diagnostic sqlite-server.go file that includes extra extension loading tests
        cat > server_diagnostic.go << 'EOF'
// Simple diagnostic program to test SQLite extension loading
package main

import (
	"database/sql"
	"fmt" 
	"log"
	"os"
	"path/filepath"

	_ "github.com/mattn/go-sqlite3"
)

func main() {
	// Set up logging
	log.SetFlags(log.Lshortfile | log.LstdFlags)
	log.Println("ðŸ” SQLite Extension Loading Diagnostic Server")
	log.Println("============================================")

	// Print current working directory
	pwd, err := os.Getwd()
	if err \!= nil {
		log.Fatal(err)
	}
	log.Printf("Working directory: %s", pwd)

	// List files in current directory
	files, err := filepath.Glob("*")
	if err \!= nil {
		log.Fatal(err)
	}
	log.Printf("Files in directory: %v", files)

	// Create test extension if it doesn't exist
	testExtensionPath := "test_extension.so"
	if _, err := os.Stat(testExtensionPath); os.IsNotExist(err) {
		log.Printf("Test extension %s does not exist in the current directory", testExtensionPath)
	} else {
		log.Printf("Found test extension at %s", testExtensionPath)
	}

	log.Println("\nðŸ”Ž Opening database with extension loading enabled...")
	db, err := sql.Open("sqlite3", "test.db?_allow_load_extension=1")
	if err \!= nil {
		log.Fatalf("Failed to open database: %v", err)
	}
	defer db.Close()

	// Set connection limits (like in the real server)
	db.SetMaxOpenConns(1)
	db.SetMaxIdleConns(1)

	// Check SQLite version
	var version string
	if err := db.QueryRow("SELECT sqlite_version()").Scan(&version); err \!= nil {
		log.Printf("âŒ Failed to get SQLite version: %v", err)
	} else {
		log.Printf("âœ… SQLite version: %s", version)
	}

	// Print compile options
	rows, err := db.Query("PRAGMA compile_options;")
	if err \!= nil {
		log.Printf("âŒ Failed to query compile options: %v", err)
	} else {
		log.Println("SQLite compile options:")
		for rows.Next() {
			var option string
			rows.Scan(&option)
			log.Printf("  - %s", option)
		}
		rows.Close()
	}

	// Try enabling extensions via PRAGMA first
	log.Println("\nðŸ”Ž Enabling extensions via PRAGMA...")
	if _, err := db.Exec("PRAGMA enable_load_extension = ON"); err \!= nil {
		log.Printf("âŒ Failed to enable extensions via PRAGMA: %v", err)
	} else {
		log.Println("âœ… Successfully enabled extensions via PRAGMA")
	}

	// Try with sqlite3_enable_load_extension
	log.Println("\nðŸ”Ž Enabling extensions with sqlite3_enable_load_extension...")
	if _, err := db.Exec("SELECT sqlite3_enable_load_extension(1)"); err \!= nil {
		log.Printf("âŒ Failed to enable load_extension at runtime: %v", err)
	} else {
		log.Println("âœ… Successfully enabled load_extension at runtime")
	}

	// Check if extension loading is enabled now
	var allowExt int
	if err := db.QueryRow("PRAGMA allow_load_extension;").Scan(&allowExt); err \!= nil {
		log.Printf("âŒ Cannot query allow_load_extension setting: %v", err)
	} else {
		log.Printf("ðŸ”Ž allow_load_extension PRAGMA value: %d", allowExt)
	}

	// Check if SQLite was compiled with extension support
	log.Println("\nðŸ”Ž Checking if SQLite was compiled with extension loading...")
	var enableLoadExt, allowLoadExt int
	db.QueryRow("SELECT sqlite_compileoption_used('SQLITE_ENABLE_LOAD_EXTENSION')").Scan(&enableLoadExt)
	db.QueryRow("SELECT sqlite_compileoption_used('SQLITE_ALLOW_LOAD_EXTENSION')").Scan(&allowLoadExt)
	log.Printf("SQLITE_ENABLE_LOAD_EXTENSION: %d", enableLoadExt)
	log.Printf("SQLITE_ALLOW_LOAD_EXTENSION: %d", allowLoadExt)

	// Try to load the test extension if it exists
	log.Println("\nðŸ”Ž Attempting to load extension...")
	if _, err := os.Stat(testExtensionPath); err == nil {
		log.Printf("Trying to load extension from: %s", testExtensionPath)
		
		// Try with placeholder param
		_, err = db.Exec("SELECT load_extension(?)", testExtensionPath)
		if err \!= nil {
			log.Printf("âŒ Failed to load extension (method 1): %v", err)
			
			// Try with direct string
			loadCmd := fmt.Sprintf("SELECT load_extension('%s')", testExtensionPath)
			_, err = db.Exec(loadCmd)
			if err \!= nil {
				log.Printf("âŒ Failed to load extension (method 2): %v", err)
				
				// Try with NULL entry point
				loadCmd = fmt.Sprintf("SELECT load_extension('%s', NULL)", testExtensionPath)
				_, err = db.Exec(loadCmd)
				if err \!= nil {
					log.Printf("âŒ Failed to load extension (method 3): %v", err)
					
					// Try without extension
					_, err = db.Exec("SELECT load_extension('./test_extension')")
					if err \!= nil {
						log.Printf("âŒ Failed to load extension (method 4): %v", err)
					} else {
						log.Println("âœ… Successfully loaded extension\!")
					}
				} else {
					log.Println("âœ… Successfully loaded extension\!")
				}
			} else {
				log.Println("âœ… Successfully loaded extension\!")
			}
		} else {
			log.Println("âœ… Successfully loaded extension\!")
		}
	} else {
		log.Printf("Skipping extension loading as %s does not exist", testExtensionPath)
	}

	log.Println("\nðŸ§ª Diagnostic run complete - press Ctrl+C to exit")
	select {} // Keep the program running
}
